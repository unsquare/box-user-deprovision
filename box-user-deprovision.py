# Requirements to run this script
# 
# Python 3.6+
# pip install "boxsdk[jwt]"

import json
import csv
import os

# Formatting timestamps
from time import strftime

# Box SDK imports
from boxsdk import JWTAuth
from boxsdk import Client
from boxsdk.exception import BoxAPIException

# This prevents BoxAPIException from outputting a detailed error message
from logging.handlers import SysLogHandler, logging
logging.basicConfig(level=logging.CRITICAL)

# Colors for formatting text output in Terminal
class colors:
	END = '\033[0m'
	BLUE = '\033[94m'
	GREEN = '\033[92m'
	YELLOW = '\033[33m'
	RED = '\033[31m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'

# Hardcode the path to the csv file for testing
# user_list_path = ''

# This gets the ID of a user based on their email address
def get_user_id(email, client):
	results = client.users(limit=1, user_type='all', filter_term=email)
	try:
		# There should only be one record, but we need to iterate through the object
		user = results.next()
		return(user.id)
	except StopIteration:
		# No results, so there's nothing to iterate
		return(None)

# This prints a message to the terminal and writes it to a log file
def update_log(message, formatting):
	now = f"[{strftime('%Y-%m-%d %I:%M:%S')}] "

	if formatting is not None:
		print(f'{now}{getattr(colors, formatting)}{message}{colors.END}')
	else:
		print(f'{now}{message}')
		
	if logfile:
		logfile.write(f'{now}{message}\n')
		
if __name__ == '__main__':

	# First, initialize the logs
	logdir = (os.sep).join((os.path.dirname(os.path.abspath(__file__)), "logs"))
	
	if not os.path.exists(logdir):
		try:
			os.makedirs(logdir)
		except:
			raise SystemExit(f"{colors.RED}ERROR: Unable to create log folder!{colors.END}")

	time_stamp = strftime('%Y-%m-%d %H%M%S')
	log_name =  f"box-deprovision-users-log-{time_stamp}.txt"
	log_path = (os.sep).join((logdir, log_name))
		
	try:
		logfile = open(log_path, "x")
	except:
		update_log("ERROR: Unable to write log file!", "RED")
		raise SystemExit

	# Either load the existing config file or create a new one
	try:
		# Get the config file
		config_file = open('config.json')
		config = json.load(config_file)
		update_log(f"Config file loaded!", "BOLD" )
	except:
		# Config file does not exist
		update_log("It looks like the config file does not exist. Let's create a new one.\n\nNOTE: Most of the information we need is available in a JSON file downloaded from the Box Developer console when you set up an app configuration or add a new public/private key pair.\n", "BOLD")
		
		json_file_path = input("Path to the JSON file generated by Box? ").replace("\ ", " ").rstrip()
		json_file = open(json_file_path)
		info = json.load(json_file)
		
		config = {}
		
		config['clientID'] = info['boxAppSettings']['clientID']
		config['clientSecret'] = info['boxAppSettings']['clientSecret']
		config['publicKeyID'] = info['boxAppSettings']['appAuth']['publicKeyID']
		config['passphrase'] = info['boxAppSettings']['appAuth']['passphrase']
		config['enterpriseID'] = info['enterpriseID']

		private_key_raw = info['boxAppSettings']['appAuth']['privateKey']
		
		try:
			pem_file_name = 'box-deprovision-users.pem'
			pem_file = open(pem_file_name, 'x')
			pem_file.write(private_key_raw)
			pem_file.close()
			os.chmod(pem_file_name, 0o0400)
			config['rsa_private_key_path'] = pem_file.name
			update_log(f"Generated private key file at {pem_file.name}\n", "BOLD")
		except Exception as error:
			update_log(f"Unable to create private key file: {error}", "RED")
			
		config['admin_user'] = input("Admin User? (Appears as the person who made changes in Box.) ").rstrip()
		config['destination_user'] = input("Destination User? (The user account that will receive transferred files.) ").rstrip()
		
		try:
			with open('config.json', 'x') as json_file:
				json.dump(config, json_file)
				
			update_log("Successfully created new config.json file.\n", "BOLD")
		except Exception as error:
			update_log(f"Unable to create config file: {error}", "RED")

	# Authenticate with the Box API
	auth = JWTAuth(
		client_id=config['clientID'],
		client_secret=config['clientSecret'],
		enterprise_id=config['enterpriseID'],
		jwt_key_id=config['publicKeyID'],
		rsa_private_key_passphrase=config['passphrase'],
		rsa_private_key_file_sys_path=config['rsa_private_key_path']
	)

	try:
		access_token = auth.authenticate_instance()
		client = Client(auth)
	except BoxAPIException as error:
		update_log(f"Box API Error: {error.message}", "RED")
		raise SystemExit
	
	# Get the admin user's ID
	admin_id = get_user_id(config['admin_user'], client)
	
	if(admin_id is not None):
		# Create a client for the admin user we're using to make changes
		user_to_impersonate = client.user(user_id=admin_id)
		admin_client = client.as_user(user_to_impersonate)
		update_log(f'Performing transfers as {admin_client.user().get().name}, Box ID #{admin_client.user().get().id}', "BOLD")
	else:
		admin_client = client
		update_log(f"{config['admin_user']} does not exist. Performing transfers as {admin_client.user().get().name}, Box ID #{admin_client.user().get().id}.", "RED")
	
	try:
		# Get the destination user's ID
		destination_user_id = get_user_id(config['destination_user'], admin_client)
		new_owner = admin_client.user(destination_user_id)
	
		update_log(f'Files will be transferred to {new_owner.get().name}, Box ID #{new_owner.get().id}', "BOLD")
	except BoxAPIException as error:
		update_log(f"Unable to get information for {config['destination_user']}: {error.message}", "RED")
		raise SystemExit

	# Get a list of users from a CSV
	if "user_list_path" not in globals():
		user_list_path = input(f"\n{colors.BLUE}Path to list of users (.csv files only)? {colors.END}").replace("\ ", " ").rstrip()

	try:
		with open(user_list_path, mode ='r')as file:
			update_log(f"Reading CSV file at {user_list_path}", "BOLD")
		
			# reading the CSV file
			csvFile = csv.DictReader(file)
		
			users_to_deprovision = []
		
			for row in csvFile:
				user_id = get_user_id(row['Email'], admin_client)
				if user_id is not None:
					users_to_deprovision.append({"Email": row['Email'], "ID": user_id})
					update_log(f"Box account found for {row['Email']}", "BLUE")
				else:
					update_log(f"Box account does not exist for {row['Email']}", "RED")
		
			if (len(users_to_deprovision) > 0):
				update_log(f'Total Users: {len(users_to_deprovision)}', "BOLD")			
				update_log('Email Addresses: ' + ', '.join(user['Email'] for user in users_to_deprovision), "BOLD")
		
				response = input(f'\n{colors.BLUE}Transfer files for these users? ({colors.BOLD}Y{colors.END}{colors.BLUE}/n) {colors.END}') or "Y"
		
				if response == "Y":
					# Transfer file ownership
					update_log(f"Transferring file ownership for {len(users_to_deprovision)} users...\n", "BOLD")
		
					for user in users_to_deprovision:
						previous_owner = admin_client.user(user['ID'])		
		
						update_log(f'Transferring files from {previous_owner.get().name}, {user["Email"]}', "BOLD")
					
						try:
							folder = previous_owner.transfer_content(new_owner)
							update_log(f'Transferred all files and folders to {folder.name}', "BOLD")
						except BoxAPIException as error:
							update_log(f"Unable to transfer files for {previous_owner.get().name}, {user['Email']}: {error.message}", "RED")
							continue
						
				else:
					update_log("No files will be transferred.", "RED")
			
				response = input(f'\n{colors.BLUE}Delete accounts for {colors.BOLD}{len(users_to_deprovision)}{colors.END}{colors.BLUE} users? ({colors.BOLD}Y{colors.END}{colors.BLUE}/n) {colors.END}') or "Y"
		
				if response == "Y":			
					update_log(f"Deleting accounts for {len(users_to_deprovision)} users...", "BOLD")
			
					for user in users_to_deprovision:			
						try:
							update_log(f"Deleting account for {user['Email']}", "BOLD")
							client.user(user['ID']).delete(notify=False, force=False)
							update_log(f"Successfully deleted Box account for {user['Email']}\n", "BOLD")
						except BoxAPIException as error:
							update_log(f"Unable to delete {user['Email']}: {error.message}", "RED")
							continue
				else:
					update_log("Users will not be deleted.", "RED")
			
				update_log("Deprovisioning is complete!", "BOLD")
			else:
				update_log("No valid users to deprovision!", "RED")
		
			logfile.close()
	except:
		update_log(f"Unable to read CSV at {user_list_path}", "RED")
		logfile.close()